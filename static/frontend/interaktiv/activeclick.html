<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Magical Shield Effect</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="scene"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
      // Basic setup
      const canvas = document.getElementById("scene");
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 0, 3);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Shader shield
      const geometry = new THREE.SphereBufferGeometry(1, 64, 64);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uPulse: { value: 0 },
          uHitTime: { value: -10 },
          uHitPos: { value: new THREE.Vector3(0, 0, 1) },
        },
        vertexShader: `
        uniform float uTime;
        uniform float uPulse;
        uniform float uHitTime;
        uniform vec3 uHitPos;
        varying vec3 vNormal;
        varying float vWave;
        void main() {
          vNormal = normal;
          vec3 pos = position;
          // global breathing pulse
          float pulse = sin(uTime * 3.0) * 0.02 * uPulse;
          pos += normal * pulse;
          // impact ripple
          float dt = uTime - uHitTime;
          if(dt > 0.0) {
            float d = acos(dot(normalize(pos), normalize(uHitPos)));
            float wave = sin(10.0 * d - dt * 8.0) * exp(-d * 5.0) * exp(-dt * 2.0);
            pos += normal * wave * 0.1;
            vWave = wave;
          } else {
            vWave = 0.0;
          }
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
        fragmentShader: `
        uniform float uTime;
        varying vec3 vNormal;
        varying float vWave;
        void main() {
          float intensity = dot(normalize(vNormal), vec3(0,0,1));
          vec3 base = vec3(0.2,0.2,1.0);
          vec3 glow = vec3(1.0,1.0,1.0) * vWave * 5.0;
          vec3 color = mix(vec3(0.05), base, intensity);
          color += glow;
          gl_FragColor = vec4(color, 0.8);
        }
      `,
        transparent: true,
      });
      const shield = new THREE.Mesh(geometry, material);
      scene.add(shield);

      // Raycaster for hit detection
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      window.addEventListener("pointerdown", (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(shield);
        if (intersects.length > 0) {
          const pt = intersects[0].point.clone().normalize();
          material.uniforms.uHitPos.value.copy(pt);
          material.uniforms.uHitTime.value = material.uniforms.uTime.value;
          material.uniforms.uPulse.value = 1;
        }
      });

      // Animation loop
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        material.uniforms.uTime.value = clock.getElapsedTime();
        // decay pulse
        material.uniforms.uPulse.value *= 0.98;
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle resize
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
