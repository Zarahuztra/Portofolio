<!DOCTYPE html>
<html lang="no">
  <head>
    <meta charset="UTF-8" />
    <title>Voxel Billboard Castle (Z-Fighting Fix Attempt)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #282c34;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x282c34);
      scene.fog = new THREE.Fog(scene.background, 40, 150);

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1, // Kan vurdere å øke denne til f.eks. 0.5 eller 1 hvis problemer vedvarer
        1000
      );
      camera.position.set(0, 15, 55);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        // logarithmicDepthBuffer: true, // Fjernet for denne testen
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 10;
      controls.maxDistance = 150;

      const ambientLight = new THREE.AmbientLight(0x404050, 0.7);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0x777788, 0.3);
      dirLight.position.set(30, 40, 20);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      const dS = 40; // Shadow frustum size
      dirLight.shadow.camera.left = -dS;
      dirLight.shadow.camera.right = dS;
      dirLight.shadow.camera.top = dS;
      dirLight.shadow.camera.bottom = -dS;
      dirLight.shadow.camera.near = 1;
      dirLight.shadow.camera.far = 100;
      dirLight.shadow.bias = -0.001; // Kan prøve å justere denne litt (f.eks. -0.005)
      scene.add(dirLight);

      const castleGroup = new THREE.Group();
      scene.add(castleGroup);

      const stoneColorPalette = [0x303035, 0x38383d, 0x404045, 0x2a2a2f];
      const mossColor = 0x2d451b;
      const darkMossColor = 0x1a2d0f;
      const grassColor = 0x3f5a27;
      const woodColor = 0x4d3027;
      const leavesColor = 0x355521;
      const fireEmissiveColor = new THREE.Color(0xff6c00);
      const lampEmissiveColor = new THREE.Color(0xffd0a2);
      const billboardColor1 = new THREE.Color(0xff00ff);
      const billboardColor2 = new THREE.Color(0x00ffff);
      const billboardColor3 = new THREE.Color(0xffff00);

      const voxelSize = 1;
      const halfVoxel = voxelSize / 2;

      // --- Hjelpefunksjoner ---
      function createVoxel(color, x, y, z) {
        const geo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
        const mat = new THREE.MeshStandardMaterial({ color: color });
        const voxel = new THREE.Mesh(geo, mat);
        voxel.position.set(x * voxelSize, y * voxelSize, z * voxelSize);
        voxel.castShadow = true;
        voxel.receiveShadow = true;
        castleGroup.add(voxel);
        return voxel;
      }

      function createStoneSection(
        baseX,
        baseY_stone_bottom_center,
        baseZ,
        width,
        height,
        depth,
        options = {}
      ) {
        const {
          irregularity = 0.2,
          mossChance = 0.1,
          openFaces = {},
          window: windowOpt = null,
          isBillboardBase = false,
        } = options;
        for (let y_layer = 0; y_layer < height; y_layer++) {
          for (let x_coord = 0; x_coord < width; x_coord++) {
            for (let z_coord = 0; z_coord < depth; z_coord++) {
              let skipVoxel = false;
              if (
                windowOpt &&
                x_coord > 0 &&
                x_coord < width - 1 &&
                z_coord > 0 &&
                z_coord < depth - 1 &&
                y_layer > 0 &&
                y_layer < height - 1 &&
                windowOpt.xRange &&
                x_coord >= windowOpt.xRange[0] &&
                x_coord <= windowOpt.xRange[1] &&
                windowOpt.yRange &&
                y_layer >= windowOpt.yRange[0] &&
                y_layer <= windowOpt.yRange[1] &&
                windowOpt.zFixed !== undefined &&
                z_coord === windowOpt.zFixed
              ) {
                skipVoxel = true;
              }
              if (!skipVoxel) {
                let isOnOpenFace = false;
                if (openFaces.front && z_coord === depth - 1)
                  isOnOpenFace = true;
                else if (openFaces.back && z_coord === 0) isOnOpenFace = true;
                else if (openFaces.left && x_coord === 0) isOnOpenFace = true;
                else if (openFaces.right && x_coord === width - 1)
                  isOnOpenFace = true;
                else if (openFaces.top && y_layer === height - 1)
                  isOnOpenFace = true;
                else if (openFaces.bottom && y_layer === 0) isOnOpenFace = true;
                if (isOnOpenFace && Math.random() < 0.35) {
                  skipVoxel = true;
                }
              }
              if (skipVoxel && !isBillboardBase) {
                continue;
              }

              let voxelYCenter = baseY_stone_bottom_center + y_layer;
              let voxelXCenter = baseX + x_coord;
              let voxelZCenter = baseZ + z_coord;

              if (Math.random() < irregularity && !isBillboardBase)
                voxelXCenter += (Math.random() - 0.5) * 0.3;
              if (Math.random() < irregularity && !isBillboardBase)
                voxelZCenter += (Math.random() - 0.5) * 0.3;

              if (Math.random() > 0.05 || y_layer === 0 || isBillboardBase) {
                const chosenStoneColor = isBillboardBase
                  ? 0x1a1a1d
                  : stoneColorPalette[
                      Math.floor(Math.random() * stoneColorPalette.length)
                    ];
                const voxel = createVoxel(
                  chosenStoneColor,
                  voxelXCenter,
                  voxelYCenter,
                  voxelZCenter
                );
                if (isBillboardBase) voxel.isBillboardPixelBase = true;

                if (
                  !isBillboardBase &&
                  y_layer < height - 1 &&
                  Math.random() < mossChance
                ) {
                  const moss = createVoxel(
                    mossColor,
                    voxelXCenter,
                    voxelYCenter + 0.55,
                    voxelZCenter
                  );
                  moss.scale.set(0.8, 0.15, 0.8);
                }
              }
            }
          }
        }
        return baseY_stone_bottom_center + height - 1 + halfVoxel;
      }

      function addGrassAndMossLayer(
        baseX,
        baseY_grass_bottom,
        baseZ,
        width,
        depth,
        thickness = 0.3
      ) {
        for (let x = 0; x < width; x++) {
          for (let z = 0; z < depth; z++) {
            const grass = createVoxel(
              grassColor,
              baseX + x,
              baseY_grass_bottom + thickness / 2,
              baseZ + z
            );
            grass.scale.y = thickness / voxelSize;
            if (Math.random() < 0.6) {
              const moss = createVoxel(
                mossColor,
                baseX + x + (Math.random() - 0.5) * 0.5,
                baseY_grass_bottom + thickness + 0.05,
                baseZ + z + (Math.random() - 0.5) * 0.5
              );
              moss.scale.set(
                Math.random() * 0.5 + 0.3,
                0.1 + Math.random() * 0.1,
                Math.random() * 0.5 + 0.3
              );
            }
            if (
              (x === 0 || x === width - 1 || z === 0 || z === depth - 1) &&
              Math.random() < 0.25
            ) {
              addHangingVines(
                baseX + x,
                baseY_grass_bottom,
                baseZ + z,
                1 + Math.random() * 2,
                darkMossColor
              );
            }
          }
        }
        return baseY_grass_bottom + thickness;
      }

      function addHangingVines(
        startX,
        startY,
        startZ,
        maxLength = 3,
        color = woodColor
      ) {
        let currentY = startY - halfVoxel;
        let currentX = startX;
        let currentZ = startZ;
        const vineLength = Math.random() * maxLength + 1;
        for (let i = 0; i < vineLength; i++) {
          const vineGeo = new THREE.CylinderGeometry(
            0.05,
            0.08,
            voxelSize * 0.8,
            5
          );
          const vineMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.8,
          });
          const vineSegment = new THREE.Mesh(vineGeo, vineMat);
          vineSegment.position.set(
            currentX,
            currentY - voxelSize * 0.4,
            currentZ
          );
          vineSegment.castShadow = true;
          castleGroup.add(vineSegment);
          currentY -= voxelSize * 0.7;
          currentX += (Math.random() - 0.5) * 0.2;
          currentZ += (Math.random() - 0.5) * 0.2;
          if (Math.random() < 0.1 && i < vineLength - 1) {
            addHangingVines(
              currentX + (Math.random() > 0.5 ? 0.3 : -0.3),
              currentY + voxelSize * 0.7,
              currentZ + (Math.random() > 0.5 ? 0.3 : -0.3),
              maxLength * 0.5,
              color
            );
          }
        }
      }

      function addTree(baseX, plantingSurfaceY, baseZ, scale = 1) {
        const trunkHeight = (1.5 + Math.random() * 0.5) * scale;
        const trunkRadius = (0.2 + Math.random() * 0.1) * scale;
        const canopyRadius = (0.8 + Math.random() * 0.3) * scale;
        const canopySegments = 7;
        const trunkGeo = new THREE.CylinderGeometry(
          trunkRadius * 0.7,
          trunkRadius,
          trunkHeight,
          8
        );
        const trunkMat = new THREE.MeshStandardMaterial({ color: woodColor });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set(baseX, plantingSurfaceY + trunkHeight / 2, baseZ);
        trunk.castShadow = true;
        castleGroup.add(trunk);
        const canopyY = plantingSurfaceY + trunkHeight + canopyRadius * 0.3;
        const canopyGeo = new THREE.SphereGeometry(
          canopyRadius,
          canopySegments,
          canopySegments
        );
        const canopyMat = new THREE.MeshStandardMaterial({
          color: leavesColor,
        });
        for (let i = 0; i < 3; i++) {
          const sphere = new THREE.Mesh(canopyGeo, canopyMat);
          sphere.position.set(
            baseX + (Math.random() - 0.5) * canopyRadius * 0.5,
            canopyY + (Math.random() - 0.5) * canopyRadius * 0.3,
            baseZ + (Math.random() - 0.5) * canopyRadius * 0.5
          );
          sphere.castShadow = true;
          castleGroup.add(sphere);
        }
        for (let i = 0; i < 3; i++) {
          addHangingVines(
            baseX + (Math.random() - 0.5) * trunkRadius,
            plantingSurfaceY + 0.2,
            baseZ + (Math.random() - 0.5) * trunkRadius,
            0.5 + Math.random() * 0.5,
            woodColor
          );
        }
      }

      function addLamp(x, bulbCenterY, z, intensity = 1.5) {
        const bulbGeo = new THREE.SphereGeometry(0.15, 12, 12);
        const bulbMat = new THREE.MeshStandardMaterial({
          color: lampEmissiveColor,
          emissive: lampEmissiveColor,
          emissiveIntensity: intensity,
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.set(x, bulbCenterY, z);
        castleGroup.add(bulb);
        const pointLight = new THREE.PointLight(
          lampEmissiveColor,
          intensity,
          5,
          2
        );
        pointLight.position.set(x, bulbCenterY, z);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 128;
        pointLight.shadow.mapSize.height = 128;
        castleGroup.add(pointLight);
      }

      function addFire(x, fireCenterY, z, intensity = 2) {
        const fireGeo = new THREE.SphereGeometry(
          0.3 + Math.random() * 0.2,
          8,
          8
        );
        const fireMat = new THREE.MeshStandardMaterial({
          color: fireEmissiveColor,
          emissive: fireEmissiveColor,
          emissiveIntensity: intensity,
          transparent: true,
          opacity: 0.8,
        });
        const fireMesh = new THREE.Mesh(fireGeo, fireMat);
        fireMesh.position.set(x, fireCenterY, z);
        castleGroup.add(fireMesh);
        const fireLight = new THREE.PointLight(
          fireEmissiveColor,
          intensity,
          7,
          2
        );
        fireLight.position.set(x, fireCenterY, z);
        fireLight.castShadow = true;
        castleGroup.add(fireLight);
        return fireLight;
      }

      // --- Billboard-logikk ---
      const billboards = [];

      function createBillboardSurface(
        baseX_corner,
        baseY_corner,
        baseZ_corner,
        numPixelsWide,
        numPixelsHigh,
        pixelOrientationNormal = "z"
      ) {
        const pixelSize = 0.9;
        const pixelSpacing = 1.0; // Bør være lik voxelSize for å passe rutenettet
        const clearance = 0.02; // Økt for mer avstand

        const pixelMaterials = [];

        for (let r = 0; r < numPixelsHigh; r++) {
          const rowMaterials = [];
          for (let c = 0; c < numPixelsWide; c++) {
            const mat = new THREE.MeshStandardMaterial({
              color: 0x101010,
              emissive: 0x000000,
              emissiveIntensity: 1.0,
              roughness: 0.8,
              metalness: 0.1,
              side: THREE.FrontSide, // Tegn kun forsiden
              polygonOffset: true, // <<< NYTT: Aktiver polygon offset
              polygonOffsetFactor: -1,
              // <<< NYTT: Dytt litt "bakover" relativt til andre ting på samme dybde
              //      Prøv -1, -0.5, -0.1. For piksel-på-base kan positivt også virke.
              //      For piksler ved siden av hverandre, er det kanskje ikke faktoren som er viktigst,
              //      men at offset er aktivert.
              polygonOffsetUnits: -1, // <<< NYTT: En annen enhet for offset
            });
            rowMaterials.push(mat);

            let px, py, pz;
            let geo;

            if (pixelOrientationNormal === "z") {
              px = baseX_corner + c * pixelSpacing + halfVoxel; // Sentrerer pikselen i sin celle
              py = baseY_corner + r * pixelSpacing + halfVoxel;
              pz = baseZ_corner + clearance;
              geo = new THREE.PlaneGeometry(pixelSize, pixelSize);
            } else if (pixelOrientationNormal === "x") {
              px = baseX_corner + clearance;
              py = baseY_corner + r * pixelSpacing + halfVoxel;
              pz = baseZ_corner + c * pixelSpacing + halfVoxel;
              geo = new THREE.PlaneGeometry(pixelSize, pixelSize);
              geo.rotateY(Math.PI / 2);
            } else {
              // pixelOrientationNormal === 'y'
              px = baseX_corner + c * pixelSpacing + halfVoxel;
              py = baseY_corner + clearance;
              pz = baseZ_corner + r * pixelSpacing + halfVoxel;
              geo = new THREE.PlaneGeometry(pixelSize, pixelSize);
              geo.rotateX(-Math.PI / 2);
            }

            const pixelMesh = new THREE.Mesh(geo, mat);
            pixelMesh.position.set(px, py, pz);
            pixelMesh.castShadow = false; // Piksler trenger ikke kaste skygge
            pixelMesh.receiveShadow = false; // Piksler trenger ikke motta skygge på denne måten
            castleGroup.add(pixelMesh);
          }
          pixelMaterials.push(rowMaterials);
        }

        billboards.push({
          materials: pixelMaterials,
          width: numPixelsWide,
          height: numPixelsHigh,
          timeOffset: Math.random() * 100,
          orientation: pixelOrientationNormal,
        });
      }

      function animateBillboards(time) {
        billboards.forEach((board) => {
          const t = time * 0.5 + board.timeOffset;
          for (let r = 0; r < board.height; r++) {
            for (let c = 0; c < board.width; c++) {
              const mat = board.materials[r][c];
              const wave1 = Math.sin(c * 0.5 + t);
              const wave2 = Math.sin(r * 0.4 + t * 0.8);
              const combinedWave = (wave1 + wave2) * 0.5;
              let color;
              if (combinedWave > 0.3) {
                color = billboardColor1;
              } else if (combinedWave < -0.3) {
                color = billboardColor2;
              } else {
                color = billboardColor3
                  .clone()
                  .lerp(billboardColor1, Math.abs(combinedWave * 2));
              }
              mat.emissive.copy(color);
              mat.emissiveIntensity = 0.6 + Math.abs(combinedWave) * 0.8;
              mat.needsUpdate = true;
            }
          }
        });
      }

      // --- Bygg slottet (forenklet for billboard-demo) ---
      let yPos;

      const mainBillboardBaseWidth = 7;
      const mainBillboardBaseHeight = 4;
      const mainBillboardBaseDepth = 1;

      const baseStartX = -(mainBillboardBaseWidth - 1) / 2;
      const baseStartZ = -(mainBillboardBaseDepth - 1) / 2;
      const baseStartY_stone_bottom_center = 0;

      yPos = createStoneSection(
        baseStartX,
        baseStartY_stone_bottom_center,
        baseStartZ,
        mainBillboardBaseWidth,
        mainBillboardBaseHeight,
        mainBillboardBaseDepth,
        { isBillboardBase: true }
      );

      createBillboardSurface(
        baseStartX,
        baseStartY_stone_bottom_center,
        baseStartZ + (mainBillboardBaseDepth - 1) * voxelSize + halfVoxel, // Forsiden av steinbasen
        mainBillboardBaseWidth,
        mainBillboardBaseHeight,
        "z"
      );

      let upperStructureStoneTopY = createStoneSection(
        baseStartX + 1,
        baseStartY_stone_bottom_center + mainBillboardBaseHeight,
        baseStartZ - 1,
        mainBillboardBaseWidth - 2,
        2,
        mainBillboardBaseDepth + 1,
        { irregularity: 0.2 }
      );
      let upperStructureGrassTopY = addGrassAndMossLayer(
        baseStartX + 1,
        upperStructureStoneTopY,
        baseStartZ - 1,
        mainBillboardBaseWidth - 2,
        mainBillboardBaseDepth + 1,
        0.4
      );
      addTree(baseStartX + 2, upperStructureGrassTopY, baseStartZ, 1);
      addLamp(baseStartX + 4, upperStructureGrassTopY + 0.5, baseStartZ, 1.5);

      castleGroup.position.y = 2;
      let animTime = 0;

      function animate() {
        requestAnimationFrame(animate);
        animTime += 0.02;

        castleGroup.position.y = 2 + Math.sin(animTime * 0.3) * 0.1;
        castleGroup.rotation.y = Math.sin(animTime * 0.15) * 0.02;

        animateBillboards(animTime);
        // Fjernet den separate ild-animasjonen for nå, siden ilden også ble fjernet.
        // Hvis du legger til ild igjen, må du legge til animasjonen for den.

        controls.update();
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
