<!DOCTYPE html>
<html lang="no">
  <head>
    <meta charset="UTF-8" />
    <title>Multi-Island Voxel Castle (Full Code)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #5c6e78;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x5c6e78);
      scene.fog = new THREE.Fog(scene.background, 35, 120);

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 18, 45);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 10;
      controls.maxDistance = 150;

      const ambientLight = new THREE.AmbientLight(0x708090, 0.8);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xadaaaa, 0.7);
      dirLight.position.set(30, 40, 20);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      const d = 35;
      dirLight.shadow.camera.left = -d;
      dirLight.shadow.camera.right = d;
      dirLight.shadow.camera.top = d;
      dirLight.shadow.camera.bottom = -d; // Korrigert
      dirLight.shadow.camera.near = 1;
      dirLight.shadow.camera.far = 100;
      dirLight.shadow.bias = -0.001;
      scene.add(dirLight);

      const castleGroup = new THREE.Group();
      scene.add(castleGroup);

      const stoneColorPalette = [0x606060, 0x686868, 0x707070, 0x5a5a5a];
      const mossColor = 0x3d552b;
      const darkMossColor = 0x2a3d1f;
      const grassColor = 0x4f6a37;
      const woodColor = 0x5d4037;
      const leavesColor = 0x456531;
      const fireEmissiveColor = new THREE.Color(0xff8c00);
      const lampEmissiveColor = new THREE.Color(0xffe0b2);
      const voxelSize = 1;
      const halfVoxel = voxelSize / 2;

      // --- Hjelpefunksjoner ---
      function createVoxel(color, x, y, z) {
        const geo = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
        const mat = new THREE.MeshStandardMaterial({ color: color });
        const voxel = new THREE.Mesh(geo, mat);
        voxel.position.set(x * voxelSize, y * voxelSize, z * voxelSize);
        voxel.castShadow = true;
        voxel.receiveShadow = true;
        castleGroup.add(voxel);
        return voxel;
      }

      function createStoneSection(
        baseX,
        baseY_stone_bottom_center,
        baseZ,
        width,
        height,
        depth,
        options = {}
      ) {
        const {
          irregularity = 0.2,
          mossChance = 0.1,
          openFaces = {},
          window: windowOpt = null,
        } = options;
        for (let y_layer = 0; y_layer < height; y_layer++) {
          for (let x_coord = 0; x_coord < width; x_coord++) {
            for (let z_coord = 0; z_coord < depth; z_coord++) {
              let skipVoxel = false;
              if (
                windowOpt &&
                x_coord > 0 &&
                x_coord < width - 1 &&
                z_coord > 0 &&
                z_coord < depth - 1 &&
                y_layer > 0 &&
                y_layer < height - 1 &&
                windowOpt.xRange &&
                x_coord >= windowOpt.xRange[0] &&
                x_coord <= windowOpt.xRange[1] &&
                windowOpt.yRange &&
                y_layer >= windowOpt.yRange[0] &&
                y_layer <= windowOpt.yRange[1] &&
                windowOpt.zFixed !== undefined &&
                z_coord === windowOpt.zFixed
              ) {
                skipVoxel = true;
              }
              if (!skipVoxel) {
                let isOnOpenFace = false;
                if (openFaces.front && z_coord === depth - 1)
                  isOnOpenFace = true;
                else if (openFaces.back && z_coord === 0) isOnOpenFace = true;
                else if (openFaces.left && x_coord === 0) isOnOpenFace = true;
                else if (openFaces.right && x_coord === width - 1)
                  isOnOpenFace = true;
                else if (openFaces.top && y_layer === height - 1)
                  isOnOpenFace = true;
                else if (openFaces.bottom && y_layer === 0) isOnOpenFace = true;
                if (isOnOpenFace && Math.random() < 0.35) {
                  skipVoxel = true;
                }
              }
              if (skipVoxel) {
                continue;
              }
              let voxelYCenter = baseY_stone_bottom_center + y_layer;
              let voxelXCenter = baseX + x_coord;
              let voxelZCenter = baseZ + z_coord;
              if (Math.random() < irregularity)
                voxelXCenter += (Math.random() - 0.5) * 0.3;
              if (Math.random() < irregularity)
                voxelZCenter += (Math.random() - 0.5) * 0.3;
              if (Math.random() > 0.05 || y_layer === 0) {
                const chosenStoneColor =
                  stoneColorPalette[
                    Math.floor(Math.random() * stoneColorPalette.length)
                  ];
                createVoxel(
                  chosenStoneColor,
                  voxelXCenter,
                  voxelYCenter,
                  voxelZCenter
                );
                if (y_layer < height - 1 && Math.random() < mossChance) {
                  const moss = createVoxel(
                    mossColor,
                    voxelXCenter,
                    voxelYCenter + 0.55,
                    voxelZCenter
                  );
                  moss.scale.set(0.8, 0.15, 0.8);
                }
              }
            }
          }
        }
        return baseY_stone_bottom_center + height - 1 + halfVoxel;
      }

      function addGrassAndMossLayer(
        baseX,
        baseY_grass_bottom,
        baseZ,
        width,
        depth,
        thickness = 0.3
      ) {
        for (let x = 0; x < width; x++) {
          for (let z = 0; z < depth; z++) {
            const grass = createVoxel(
              grassColor,
              baseX + x,
              baseY_grass_bottom + thickness / 2,
              baseZ + z
            );
            grass.scale.y = thickness / voxelSize;
            if (Math.random() < 0.6) {
              const moss = createVoxel(
                mossColor,
                baseX + x + (Math.random() - 0.5) * 0.5,
                baseY_grass_bottom + thickness + 0.05,
                baseZ + z + (Math.random() - 0.5) * 0.5
              );
              moss.scale.set(
                Math.random() * 0.5 + 0.3,
                0.1 + Math.random() * 0.1,
                Math.random() * 0.5 + 0.3
              );
            }
            if (
              (x === 0 || x === width - 1 || z === 0 || z === depth - 1) &&
              Math.random() < 0.25
            ) {
              addHangingVines(
                baseX + x,
                baseY_grass_bottom,
                baseZ + z,
                1 + Math.random() * 2,
                darkMossColor
              );
            }
          }
        }
        return baseY_grass_bottom + thickness;
      }

      function addHangingVines(
        startX,
        startY,
        startZ,
        maxLength = 3,
        color = woodColor
      ) {
        let currentY = startY - halfVoxel;
        let currentX = startX;
        let currentZ = startZ;
        const vineLength = Math.random() * maxLength + 1;
        for (let i = 0; i < vineLength; i++) {
          const vineGeo = new THREE.CylinderGeometry(
            0.05,
            0.08,
            voxelSize * 0.8,
            5
          );
          const vineMat = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.8,
          });
          const vineSegment = new THREE.Mesh(vineGeo, vineMat);
          vineSegment.position.set(
            currentX,
            currentY - voxelSize * 0.4,
            currentZ
          );
          vineSegment.castShadow = true;
          castleGroup.add(vineSegment);
          currentY -= voxelSize * 0.7;
          currentX += (Math.random() - 0.5) * 0.2;
          currentZ += (Math.random() - 0.5) * 0.2;
          if (Math.random() < 0.1 && i < vineLength - 1) {
            addHangingVines(
              currentX + (Math.random() > 0.5 ? 0.3 : -0.3),
              currentY + voxelSize * 0.7,
              currentZ + (Math.random() > 0.5 ? 0.3 : -0.3),
              maxLength * 0.5,
              color
            );
          }
        }
      }

      function addTree(baseX, plantingSurfaceY, baseZ, scale = 1) {
        const trunkHeight = (1.5 + Math.random() * 0.5) * scale;
        const trunkRadius = (0.2 + Math.random() * 0.1) * scale;
        const canopyRadius = (0.8 + Math.random() * 0.3) * scale;
        const canopySegments = 7;
        const trunkGeo = new THREE.CylinderGeometry(
          trunkRadius * 0.7,
          trunkRadius,
          trunkHeight,
          8
        );
        const trunkMat = new THREE.MeshStandardMaterial({ color: woodColor });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set(baseX, plantingSurfaceY + trunkHeight / 2, baseZ);
        trunk.castShadow = true;
        castleGroup.add(trunk);
        const canopyY = plantingSurfaceY + trunkHeight + canopyRadius * 0.3;
        const canopyGeo = new THREE.SphereGeometry(
          canopyRadius,
          canopySegments,
          canopySegments
        );
        const canopyMat = new THREE.MeshStandardMaterial({
          color: leavesColor,
        });
        for (let i = 0; i < 3; i++) {
          const sphere = new THREE.Mesh(canopyGeo, canopyMat);
          sphere.position.set(
            baseX + (Math.random() - 0.5) * canopyRadius * 0.5,
            canopyY + (Math.random() - 0.5) * canopyRadius * 0.3,
            baseZ + (Math.random() - 0.5) * canopyRadius * 0.5
          );
          sphere.castShadow = true;
          castleGroup.add(sphere);
        }
        for (let i = 0; i < 3; i++) {
          addHangingVines(
            baseX + (Math.random() - 0.5) * trunkRadius,
            plantingSurfaceY + 0.2,
            baseZ + (Math.random() - 0.5) * trunkRadius,
            0.5 + Math.random() * 0.5,
            woodColor
          );
        }
      }

      function addLamp(x, bulbCenterY, z, intensity = 1.5) {
        const bulbGeo = new THREE.SphereGeometry(0.15, 12, 12);
        const bulbMat = new THREE.MeshStandardMaterial({
          color: lampEmissiveColor,
          emissive: lampEmissiveColor,
          emissiveIntensity: intensity,
        });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.set(x, bulbCenterY, z);
        castleGroup.add(bulb);
        const pointLight = new THREE.PointLight(
          lampEmissiveColor,
          intensity,
          5,
          2
        );
        pointLight.position.set(x, bulbCenterY, z);
        pointLight.castShadow = true;
        pointLight.shadow.mapSize.width = 128;
        pointLight.shadow.mapSize.height = 128;
        castleGroup.add(pointLight);
      }

      function addFire(x, fireCenterY, z, intensity = 2) {
        const fireGeo = new THREE.SphereGeometry(
          0.3 + Math.random() * 0.2,
          8,
          8
        );
        const fireMat = new THREE.MeshStandardMaterial({
          color: fireEmissiveColor,
          emissive: fireEmissiveColor,
          emissiveIntensity: intensity,
          transparent: true,
          opacity: 0.8,
        });
        const fireMesh = new THREE.Mesh(fireGeo, fireMat);
        fireMesh.position.set(x, fireCenterY, z);
        castleGroup.add(fireMesh);
        const fireLight = new THREE.PointLight(
          fireEmissiveColor,
          intensity,
          7,
          2
        );
        fireLight.position.set(x, fireCenterY, z);
        fireLight.castShadow = true;
        castleGroup.add(fireLight);
        return fireLight;
      }

      // --- NY FUNKSJON FOR Å BYGGE ET SIDESLOTT ---
      function buildSideCastle(
        offsetX_of_connection_point,
        connectionY_stone_bottom,
        connectionZ_center,
        direction
      ) {
        // direction: -1 for left, 1 for right
        const bridgeLength = 5 + Math.random() * 2;
        const bridgeWidth = 2;
        let yPos;

        // 1. Bygg broen
        const bridgeStoneBaseX =
          offsetX_of_connection_point + direction * (bridgeLength / 2);
        yPos = createStoneSection(
          bridgeStoneBaseX - (bridgeWidth - 1) / 2, // Senter X for broens stein
          connectionY_stone_bottom, // Y for bunnen av broens stein
          connectionZ_center -
            ((bridgeLength - 1) / 2) * (direction === 0 ? 1 : 0), //  Z for broens stein (juster hvis broen går i Z)
          bridgeWidth,
          1,
          bridgeLength,
          { irregularity: 0.1 }
        );
        let bridgeGrassTopY = addGrassAndMossLayer(
          bridgeStoneBaseX - (bridgeWidth - 1) / 2,
          yPos,
          connectionZ_center -
            ((bridgeLength - 1) / 2) * (direction === 0 ? 1 : 0),
          bridgeWidth,
          bridgeLength,
          0.3
        );

        // 2. Bygg selve sideslottet
        const sideCastleCenterX =
          offsetX_of_connection_point +
          direction * (bridgeLength + 2 + Math.random() * 2); // Plasser forbi broen
        const sideCastleCenterY_stone_bottom =
          connectionY_stone_bottom - 1 + Math.random() * 2; // Varier høyden litt
        const sideCastleCenterZ =
          connectionZ_center + (Math.random() - 0.5) * 3;

        const scWidth = 4 + Math.floor(Math.random() * 3);
        const scHeight = 3 + Math.floor(Math.random() * 3);
        const scDepth = 3 + Math.floor(Math.random() * 2);

        yPos = createStoneSection(
          sideCastleCenterX - (scWidth - 1) / 2,
          sideCastleCenterY_stone_bottom,
          sideCastleCenterZ - (scDepth - 1) / 2,
          scWidth,
          scHeight,
          scDepth,
          {
            irregularity: 0.3,
            mossChance: 0.2,
            openFaces: {
              top: true,
              front: Math.random() > 0.5,
              back: Math.random() > 0.5,
            },
          }
        );
        let sideCastleGrassTopY = addGrassAndMossLayer(
          sideCastleCenterX - (scWidth - 1) / 2,
          yPos,
          sideCastleCenterZ - (scDepth - 1) / 2,
          scWidth,
          scDepth,
          0.4
        );

        const numTrees = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < numTrees; i++) {
          addTree(
            sideCastleCenterX + (Math.random() - 0.5) * (scWidth * 0.6),
            sideCastleGrassTopY,
            sideCastleCenterZ + (Math.random() - 0.5) * (scDepth * 0.6),
            0.8 + Math.random() * 0.4
          );
        }

        // 3. Nye utstikkere på sideslottet
        const numOutstickers = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < numOutstickers; i++) {
          const outstickerWidth = 2 + Math.floor(Math.random() * 2);
          const outstickerDepth = 2 + Math.floor(Math.random() * 2);
          const outstickerSideDir = Math.random() > 0.5 ? 1 : -1; // X-retning relativt til sideslottet
          //const outstickerForwardDir = Math.random() > 0.5 ? 1: -1; // Z-retning (brukes ikke optimalt her ennå)

          const outstickerBaseX_center =
            sideCastleCenterX +
            outstickerSideDir * (scWidth / 2 + outstickerWidth / 2 + 0.5);
          const outstickerBaseY_stone_bottom =
            sideCastleCenterY_stone_bottom +
            Math.floor(Math.random() * (scHeight - 1));
          const outstickerBaseZ_center =
            sideCastleCenterZ + (Math.random() - 0.5) * scDepth * 0.5;

          yPos = createStoneSection(
            outstickerBaseX_center - (outstickerWidth - 1) / 2,
            outstickerBaseY_stone_bottom,
            outstickerBaseZ_center - (outstickerDepth - 1) / 2,
            outstickerWidth,
            1,
            outstickerDepth,
            { irregularity: 0.1 }
          );
          let outstickerGrassTopY = addGrassAndMossLayer(
            outstickerBaseX_center - (outstickerWidth - 1) / 2,
            yPos,
            outstickerBaseZ_center - (outstickerDepth - 1) / 2,
            outstickerWidth,
            outstickerDepth,
            0.3
          );
          addHangingVines(
            outstickerBaseX_center,
            yPos - halfVoxel,
            outstickerBaseZ_center,
            2 + Math.random() * 3,
            darkMossColor
          );
          if (Math.random() < 0.3) {
            addTree(
              outstickerBaseX_center,
              outstickerGrassTopY,
              outstickerBaseZ_center,
              0.6
            );
          }
        }
      }

      // --- Bygg HOVEDSLOTTET ---
      let yPos;

      // Nedre hovedseksjon
      yPos = createStoneSection(0, 0, 0, 7, 4, 5, {
        irregularity: 0.3,
        mossChance: 0.15,
        window: { xRange: [2, 4], yRange: [1, 2], zFixed: 4 },
      });
      const fireLight = addFire(2.5, 0 + 1.5, 4.2, 2.5);

      // Midtre plattform til venstre (KOBLINGSPUNKT 1)
      const midPlatform_BaseX_center = -4; // Senter X av plattformen
      const midPlatform_BaseY_stone_bottom_center = 1;
      const midPlatform_BaseZ_center = 1; // Senter Z av plattformen
      const midPlatform_Width = 4;
      const midPlatform_Height = 2;
      const midPlatform_Depth = 3;
      let midPlatformStoneTopY = createStoneSection(
        midPlatform_BaseX_center - (midPlatform_Width - 1) / 2, // Start X for steiner
        midPlatform_BaseY_stone_bottom_center,
        midPlatform_BaseZ_center - (midPlatform_Depth - 1) / 2, // Start Z for steiner
        midPlatform_Width,
        midPlatform_Height,
        midPlatform_Depth,
        {
          irregularity: 0.2,
          openFaces: { right: true, front: true, back: true },
        }
      );
      let midPlatformGrassTopY = addGrassAndMossLayer(
        midPlatform_BaseX_center - (midPlatform_Width - 1) / 2,
        midPlatformStoneTopY,
        midPlatform_BaseZ_center - (midPlatform_Depth - 1) / 2,
        midPlatform_Width,
        midPlatform_Depth,
        0.4
      );
      addHangingVines(
        midPlatform_BaseX_center - (midPlatform_Width - 1) / 2 + 0.5,
        midPlatformStoneTopY,
        midPlatform_BaseZ_center,
        3
      );
      addHangingVines(
        midPlatform_BaseX_center,
        midPlatform_BaseY_stone_bottom_center + halfVoxel,
        midPlatform_BaseZ_center,
        4
      );

      // Øvre hovedseksjon
      let upperMainStoneTopY = createStoneSection(0.5, 4, 0.5, 6, 3, 4, {
        irregularity: 0.25,
        mossChance: 0.2,
      });
      let upperMainGrassTopY = addGrassAndMossLayer(
        0.5,
        upperMainStoneTopY,
        0.5,
        6,
        4,
        0.5
      );
      addTree(1.5, upperMainGrassTopY, 1.5, 1);
      addTree(4.5, upperMainGrassTopY, 2.5, 1.1);
      addLamp(3, upperMainGrassTopY + 0.3, 1, 1.8);
      addLamp(5.5, upperMainGrassTopY + 0.4, 3.5, 1.6);

      // Liten plattform på høyre side (KOBLINGSPUNKT 2)
      const smallRightPlatform_BaseX_center = 6.5;
      const smallRightPlatform_BaseY_stone_bottom_center = 5;
      const smallRightPlatform_BaseZ_center = 1.5;
      const smallRightPlatform_Width = 2;
      const smallRightPlatform_Height = 1;
      const smallRightPlatform_Depth = 2;
      let smallRightPlatformStoneTopY = createStoneSection(
        smallRightPlatform_BaseX_center - (smallRightPlatform_Width - 1) / 2,
        smallRightPlatform_BaseY_stone_bottom_center,
        smallRightPlatform_BaseZ_center - (smallRightPlatform_Depth - 1) / 2,
        smallRightPlatform_Width,
        smallRightPlatform_Height,
        smallRightPlatform_Depth,
        {
          irregularity: 0.1,
          openFaces: { front: true, back: true, left: true },
        }
      );
      let smallRightPlatformGrassTopY = addGrassAndMossLayer(
        smallRightPlatform_BaseX_center - (smallRightPlatform_Width - 1) / 2,
        smallRightPlatformStoneTopY,
        smallRightPlatform_BaseZ_center - (smallRightPlatform_Depth - 1) / 2,
        smallRightPlatform_Width,
        smallRightPlatform_Depth,
        0.3
      );
      addHangingVines(
        smallRightPlatform_BaseX_center,
        smallRightPlatformStoneTopY,
        smallRightPlatform_BaseZ_center,
        2
      );

      // --- BYGG SIDESLOTTENE ---
      // Venstre sideslott, koblet til midPlatform
      buildSideCastle(
        midPlatform_BaseX_center - midPlatform_Width / 2, // X-koordinaten til venstre kant av midPlatform
        midPlatform_BaseY_stone_bottom_center + (midPlatform_Height - 1), // Y for bunnen av broens stein, på høyde med toppen av midPlatform-stein
        midPlatform_BaseZ_center, // Z-senteret for tilkoblingen
        -1 // Retning: venstre
      );

      // Høyre sideslott, koblet til smallRightPlatform
      buildSideCastle(
        smallRightPlatform_BaseX_center + smallRightPlatform_Width / 2, // X-koordinaten til høyre kant av smallRightPlatform
        smallRightPlatform_BaseY_stone_bottom_center +
          (smallRightPlatform_Height - 1), // Y for bunnen av broens stein
        smallRightPlatform_BaseZ_center, // Z-senteret for tilkoblingen
        1 // Retning: høyre
      );

      castleGroup.position.y = 2; // Global Y-offset for hele greia
      let time = 0;

      function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        castleGroup.position.y = 2 + Math.sin(time * 0.7) * 0.2;
        castleGroup.rotation.y = Math.sin(time * 0.3) * 0.03;

        if (fireLight && Math.random() < 0.2) {
          fireLight.intensity = 2 + (Math.random() - 0.5) * 0.5;
          const fireMesh = fireLight.parent.children.find(
            (c) =>
              c.material &&
              c.material.emissive &&
              c.material.emissive.equals(fireEmissiveColor)
          );
          if (fireMesh) fireMesh.scale.setScalar(0.8 + Math.random() * 0.4);
        }

        controls.update();
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
