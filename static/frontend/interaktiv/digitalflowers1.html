<!DOCTYPE html>
<html lang="no">
  <head>
    <meta charset="UTF-8" />
    <title>Generative digitale blomster</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        background: #18171b;
      }
      canvas {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      }
      .hint {
        position: fixed;
        bottom: 22px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffe6d7;
        font-family: sans-serif;
        opacity: 0.4;
        font-size: 1em;
        text-shadow: 0 0 10px #010409;
        pointer-events: none;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <canvas id="flowers"></canvas>
    <div class="hint">Klikk for å så en blomst!</div>
    <script>
      const canvas = document.getElementById("flowers");
      const ctx = canvas.getContext("2d");
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      // Util-funksjoner
      function lerp(a, b, t) {
        return a + (b - a) * t;
      }
      function lerp3(a, b, t) {
        return [lerp(a[0], b[0], t), lerp(a[1], b[1], t), lerp(a[2], b[2], t)];
      }
      function rgb(arr, a = 1) {
        return `rgba(${arr[0] | 0},${arr[1] | 0},${arr[2] | 0},${a})`;
      }
      function ease(t) {
        return t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);
      }

      const PETAL_COLORS = [
        [233, 80, 119],
        [255, 198, 86],
        [107, 187, 102],
        [48, 183, 215],
        [154, 105, 230],
        [255, 140, 77],
        [255, 255, 122],
        [255, 122, 238],
        [84, 252, 205],
        [235, 105, 220],
      ];
      const CENTER_COLORS = [
        [250, 255, 205],
        [255, 200, 67],
        [255, 166, 63],
        [210, 105, 30],
        [240, 180, 230],
        [180, 210, 76],
      ];
      const STEM_COLORS = [
        [56, 174, 88],
        [75, 200, 120],
        [120, 187, 80],
        [101, 151, 78],
      ];

      // Blomsterdata
      let flowers = [];

      function spawnFlower(x, y) {
        let time = performance.now() / 1000;
        let groundY =
          y || lerp(canvas.height * 0.64, canvas.height * 0.97, Math.random());
        let cx =
          x || lerp(canvas.width * 0.09, canvas.width * 0.91, Math.random());
        let size = lerp(38, 104, Math.random());
        let petals = Math.floor(lerp(5, 13, Math.random()));
        let petalLen = lerp(size * 0.7, size * 1.28, Math.random());
        let petalW = lerp(size * 0.18, size * 0.42, Math.random());
        let angleOffset = Math.random() * Math.PI * 2;
        let color =
          PETAL_COLORS[Math.floor(Math.random() * PETAL_COLORS.length)];
        let center =
          CENTER_COLORS[Math.floor(Math.random() * CENTER_COLORS.length)];
        let stem = STEM_COLORS[Math.floor(Math.random() * STEM_COLORS.length)];
        let growTime = lerp(1.2, 2.4, Math.random());
        let showTime = lerp(2.7, 5.2, Math.random());
        let fadeTime = lerp(1.3, 2.7, Math.random());
        return {
          x: cx,
          y: groundY,
          size,
          petals,
          petalLen,
          petalW,
          angleOffset,
          color,
          center,
          stem,
          born: time,
          growTime,
          showTime,
          fadeTime,
          state: "growing",
        };
      }

      // SÅ NY BLOMST VED KLIKK
      canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        flowers.push(spawnFlower(e.clientX - rect.left, e.clientY - rect.top));
      });

      // Automatisk blomstring av og til
      let nextFlower = performance.now() + 500 + Math.random() * 1900;

      // Tegner én blomst
      function drawFlower(f, phase, alpha = 1) {
        // Stilk (vokser først)
        ctx.save();
        ctx.strokeStyle = rgb(f.stem, 0.45 * alpha);
        ctx.lineWidth = lerp(
          f.size * 0.08,
          f.size * 0.18,
          0.4 + 0.6 * Math.sin(f.x * 0.02)
        );
        ctx.beginPath();
        ctx.moveTo(f.x, canvas.height * 1.01);
        ctx.bezierCurveTo(
          f.x + lerp(-40, 40, Math.sin(f.x) * 0.56),
          lerp(
            canvas.height * 0.91,
            f.y + f.size * 0.49,
            Math.pow(phase, 0.62)
          ),
          f.x + lerp(-12, 18, Math.sin(f.x * 0.09)),
          lerp(canvas.height * 0.81, f.y + f.size * 0.15, Math.pow(phase, 0.9)),
          f.x,
          f.y
        );
        ctx.shadowColor = rgb(f.stem, 0.25 * alpha);
        ctx.shadowBlur = 16;
        ctx.stroke();
        ctx.restore();

        // Kronblader
        for (let i = 0; i < f.petals; i++) {
          let ang = (i / f.petals) * Math.PI * 2 + f.angleOffset;
          let px = f.x + Math.cos(ang) * lerp(f.size * 0.2, f.petalLen, phase);
          let py = f.y + Math.sin(ang) * lerp(f.size * 0.18, f.petalLen, phase);
          ctx.save();
          ctx.translate(f.x, f.y);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.ellipse(
            lerp(f.size * 0.15, f.petalLen, phase),
            0,
            lerp(f.petalW * 0.3, f.petalW, phase),
            lerp(
              f.size * 0.23,
              f.petalW,
              0.45 + 0.4 * Math.cos(ang + phase * 3)
            ),
            lerp(-0.15, 0.09, Math.sin(ang + phase * 2.5)),
            0,
            Math.PI * 2
          );
          ctx.shadowColor = rgb(f.color, 0.34 * alpha);
          ctx.shadowBlur = 16 + 10 * phase;
          ctx.fillStyle = rgb(f.color, lerp(0.26, 0.92, phase) * alpha);
          ctx.fill();
          ctx.restore();
        }

        // Senter
        ctx.save();
        ctx.beginPath();
        ctx.arc(
          f.x,
          f.y,
          lerp(f.size * 0.16, f.size * 0.27, phase),
          0,
          Math.PI * 2
        );
        ctx.shadowColor = rgb(f.center, 0.32 * alpha);
        ctx.shadowBlur = 20 + 10 * phase;
        ctx.fillStyle = rgb(f.center, lerp(0.33, 0.92, phase) * alpha);
        ctx.fill();
        ctx.restore();
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let now = performance.now() / 1000;

        // Automatisk spiring
        if (performance.now() > nextFlower) {
          flowers.push(spawnFlower());
          nextFlower = performance.now() + 600 + Math.random() * 1900;
        }

        // Tegn blomster og fjern de som har visnet
        for (let i = flowers.length - 1; i >= 0; i--) {
          let f = flowers[i];
          let t = now - f.born;
          let alpha = 1;
          let phase = 0;

          if (f.state === "growing") {
            phase = Math.min(1, t / f.growTime);
            if (phase >= 1) {
              f.state = "showing";
              f.born = now;
            }
          }
          if (f.state === "showing") {
            phase = 1;
            if (t > f.showTime) {
              f.state = "fading";
              f.born = now;
            }
          }
          if (f.state === "fading") {
            let fade = Math.max(0, 1 - t / f.fadeTime);
            alpha = fade;
            phase = 1;
            if (fade <= 0.01) {
              flowers.splice(i, 1);
              continue;
            }
          }
          drawFlower(f, phase, alpha);
        }

        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
