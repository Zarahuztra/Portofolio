<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Animated Spiral Tube</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100vh;
      }
      #container {
        width: 100%;
        height: 100%;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <!-- Three.js + controls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
      // --- Setup scene, camera, renderer ---
      const container = document.getElementById("container");
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        50,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 3, 10);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      // --- HelixCurve definition ---
      class HelixCurve extends THREE.Curve {
        constructor(radius, height, turns, timeOffset) {
          super();
          this.radius = radius;
          this.height = height;
          this.turns = turns;
          this.timeOffset = timeOffset || 0;
        }
        getPoint(t, optionalTarget = new THREE.Vector3()) {
          const angle = 2 * Math.PI * this.turns * t + this.timeOffset;
          const x = this.radius * Math.cos(angle);
          const z = this.radius * Math.sin(angle);
          const y = this.height * (t - 0.5); // center at y=0
          return optionalTarget.set(x, y, z);
        }
      }

      // Tube parameters
      const radialSegments = 12;
      const tubularSegments = 200;
      const tubeRadius = 0.2;
      const spiralRadius = 2.0;
      const spiralHeight = 6.0;
      const spiralTurns = 5.5;

      // Initial helix curve
      let helixCurve = new HelixCurve(
        spiralRadius,
        spiralHeight,
        spiralTurns,
        0
      );

      // Create tube mesh
      let tubeGeo = new THREE.TubeBufferGeometry(
        helixCurve,
        tubularSegments,
        tubeRadius,
        radialSegments,
        false
      );
      const tubeMat = new THREE.MeshStandardMaterial({
        color: 0x2194ce,
        side: THREE.DoubleSide,
      });
      const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
      scene.add(tubeMesh);

      // --- Animation loop ---
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        // Update the curve's timeOffset to rotate the spiral
        helixCurve.timeOffset = t * 1.0; // speed: 1.0 rad/sec

        // Rebuild geometry each frame
        const newGeo = new THREE.TubeBufferGeometry(
          helixCurve,
          tubularSegments,
          tubeRadius,
          radialSegments,
          false
        );
        tubeMesh.geometry.dispose();
        tubeMesh.geometry = newGeo;

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // Handle resizing
      window.addEventListener("resize", () => {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
