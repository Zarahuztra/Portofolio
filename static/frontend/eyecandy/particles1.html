<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Energi-Vortex with Spread Particles and Gradient</title>
    <style>
      /* Remove margins and set a black background */
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
    </style>
  </head>
  <body>
    <!-- Include three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Global variables for scene, camera, renderer, and particle system.
      let scene, camera, renderer, particleSystem;
      // Arrays for particle positions and colors.
      let positions, colors;
      // Total number of particles
      const particleCount = 10000;
      // Rotation speed for the vortex effect (for pulsation)
      const rotationSpeed = 0.0005;
      // Amplitude for the pulsation effect.
      const pulsAmplitude = 0.3;

      // NEW: Increase the spread by using larger radii.
      const minRadius = 50; // Previously 20
      const maxRadius = 150; // Previously 70

      // Arrays to store the initial angles and radii for each particle.
      let initialAngles = [];
      let initialRadii = [];

      // Base color for the particles.
      const baseColor = new THREE.Color(0x00ffcc);

      // Initialize the scene and start animation.
      init();
      animate();

      /**
       * init() - Sets up the scene, camera, renderer, and initializes particles and color attributes.
       */
      function init() {
        // Create the scene.
        scene = new THREE.Scene();

        // Create a perspective camera.
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.z = 200;
        camera.lookAt(scene.position);

        // Set up the renderer and attach it to the document.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a BufferGeometry for the particles.
        const geometry = new THREE.BufferGeometry();
        // Create a Float32Array for positions (3 values per particle).
        positions = new Float32Array(particleCount * 3);
        // Create an array for colors (r, g, b for each particle).
        colors = new Float32Array(particleCount * 3);

        // Initialize particle data: positions and colors based on radius.
        for (let i = 0; i < particleCount; i++) {
          // Generate a random angle between 0 and 2Ï€.
          const angle = Math.random() * Math.PI * 2;
          // Choose a random radius between minRadius and maxRadius.
          const radius = Math.random() * (maxRadius - minRadius) + minRadius;
          // Calculate x and y based on the angle and radius.
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          // Set a small random z value (for depth variation).
          const z = (Math.random() - 0.5) * 20;

          // Store the initial angle and radius.
          initialAngles[i] = angle;
          initialRadii[i] = radius;

          // Set particle positions.
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;

          // Determine a color gradient based on the radius.
          // Particles closer to the center (radius near minRadius) are brighter,
          // while those further out (near maxRadius) are darker.
          let brightness = 1 - (radius - minRadius) / (maxRadius - minRadius);
          brightness = Math.max(0, Math.min(1, brightness)); // clamp to [0, 1]

          colors[i * 3] = baseColor.r * brightness;
          colors[i * 3 + 1] = baseColor.g * brightness;
          colors[i * 3 + 2] = baseColor.b * brightness;
        }
        // Attach position and color attributes to geometry.
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // Create a PointsMaterial that uses vertex colors.
        const material = new THREE.PointsMaterial({
          size: 2,
          transparent: true,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
          vertexColors: true,
        });

        // Create the particle system and add it to the scene.
        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // Resize event listener.
        window.addEventListener("resize", onWindowResize, false);
      }

      /**
       * onWindowResize() - Updates camera and renderer settings when the window size changes.
       */
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      /**
       * animate() - Main animation loop.
       * @param {number} time - Time in milliseconds from requestAnimationFrame.
       */
      function animate(time) {
        requestAnimationFrame(animate);
        // Update the vortex effect (particle positions and color gradient).
        updateVortex(time);
        // NEW: Rotate the entire particle system about its own axis.
        particleSystem.rotation.y += 0.001; // adjust rotation speed as desired
        renderer.render(scene, camera);
      }

      /**
       * updateVortex() - Calculates and updates the position of each particle based on its initial values.
       * Also recalculates the color gradient based on the current radius.
       * @param {number} time - The current time for time-dependent animation.
       */
      function updateVortex(time) {
        const positionsAttr = particleSystem.geometry.attributes.position;
        const colorsAttr = particleSystem.geometry.attributes.color;
        // Update each particle.
        for (let i = 0; i < particleCount; i++) {
          let ix = i * 3;
          let iy = i * 3 + 1;
          let iz = i * 3 + 2;

          const baseAngle = initialAngles[i];
          const baseRadius = initialRadii[i];

          // Compute new angle with rotation based on time.
          let newAngle = baseAngle + rotationSpeed * time;
          // Compute a pulsation effect.
          let puls = Math.sin(baseRadius * 0.1 + time * 0.005);
          // Calculate a new radius incorporating the pulsation.
          let newRadius = baseRadius * (1 + pulsAmplitude * puls);

          // Compute new x and y positions based on new angle and radius.
          let newX = newRadius * Math.cos(newAngle);
          let newY = newRadius * Math.sin(newAngle);
          // Compute a new z position for additional depth.
          let newZ = Math.sin(time * 0.002 + baseRadius) * 5;

          // Update positions.
          positionsAttr.array[ix] = newX;
          positionsAttr.array[iy] = newY;
          positionsAttr.array[iz] = newZ;

          // Recalculate the current distance from the center.
          let distance = Math.sqrt(newX * newX + newY * newY);
          // Compute brightness for the gradient effect.
          let brightness = 1 - (distance - minRadius) / (maxRadius - minRadius);
          brightness = Math.max(0, Math.min(1, brightness));

          // Update colors for the gradient.
          colorsAttr.array[ix] = baseColor.r * brightness;
          colorsAttr.array[iy] = baseColor.g * brightness;
          colorsAttr.array[iz] = baseColor.b * brightness;
        }
        positionsAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true;
      }
    </script>
  </body>
</html>
